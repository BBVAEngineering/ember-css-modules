'use strict';

const Plugin = require('broccoli-plugin');
const Filter = require('broccoli-persistent-filter');
const Funnel = require('broccoli-funnel');
const symlinkOrCopy = require('symlink-or-copy');
const fs = require('fs');

module.exports = class TypeGenerator {
  constructor(owner) {
    this.name = 'ember-css-modules';
    this.owner = owner;
  }

  toTree(type, input) {
    if (type === 'app' || type === 'addon') {
      // Including the modules tree ensures it's been built by the time we
      // attempt to extract information from it.
      let boundInput = new FirstTreeOnly([input, this.owner.getModulesTree()]);
      let filtered = new Funnel(boundInput, {
        include: [`**/*.${this.owner.getFileExtension()}`]
      });

      return new CSSModuleTypeDeclarations(filtered, this.owner);
    }
  }
}

class FirstTreeOnly extends Plugin {
  constructor(inputs) {
    super(inputs);
    this.hasLinked = false;
  }

  build() {
    if (!this.hasLinked) {
      fs.rmdirSync(this.outputPath);
      symlinkOrCopy.sync(this.inputPaths[0], this.outputPath);
      this.hasLinked = true;
    }
  }
}

class CSSModuleTypeDeclarations extends Filter {
  constructor(input, owner) {
    super(input, {
      extensions: [owner.getFileExtension()],
      targetExtension: 'd.ts'
    });

    this.owner = owner;
  }

  processString(contents, relativePath) {
    let fullPath = `${this.owner.getOwnerName()}/${relativePath}`;

    return this.owner.getModulesTree()
      .loadPath(this.owner.resolvePath(fullPath))
      .then(result => this.generateDeclaration(result.exportTokens));
  }

  generateDeclaration(exportTokens) {
    let lines = [
      '// This is an autogenerated file. Do not edit it directly.',
      'declare const styles: {'
    ];

    for (let key of Object.keys(exportTokens)) {
      lines.push(`  '${key}': string;`);
    }

    lines.push('};', '', 'export default styles;', '');

    return lines.join('\n');
  }
}
